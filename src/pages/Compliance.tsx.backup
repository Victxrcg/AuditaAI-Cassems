import { useState, useCallback, useMemo, useEffect, memo } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { 
  Upload, 
  FileText, 
  Download, 
  Trash2, 
  Save,
  CheckCircle,
  AlertCircle,
  Calendar,
  DollarSign,
  MessageSquare,
  Plus,
  ArrowLeft,
  Eye,
  Pencil
} from 'lucide-react';
import { 
  uploadAnexo, 
  listAnexos, 
  downloadAnexo, 
  removeAnexo, 
  getTipoAnexoFromItemId, 
  formatFileSize, 
  validateFileType, 
  getFileIcon,
  type Anexo 
} from '@/services/anexosService';
import { formatDateBR, formatDateTimeBR, formatCompetenciaTitle } from '@/utils/dateUtils';

interface ComplianceItem {
  id: string;
  title: string;
  description: string;
  valor?: string;
  data?: string;
  observacoes?: string;
  anexos?: Anexo[];
  status: 'pendente' | 'concluido' | 'em_analise';
  lastUpdated?: string;
  updatedBy?: string;
}

interface Competencia {
  id: string;
  mes: string;
  ano: string;
  status: 'em_andamento' | 'concluida';
  parecer_gerado: boolean;
  created_at: string;
  created_by_nome: string;
  competencia_formatada?: string;
}

// Componente separado para ComplianceItemCard
const ComplianceItemCard = memo(({ 
  item, 
  onFieldChange, 
  onFileUpload, 
  onRemoveFile, 
  onSave, 
  gerarParecer, 
  getStatusBadge, 
  loading,
  currentCompetenciaId
}: {
  item: ComplianceItem;
  onFieldChange: (id: string, field: 'valor' | 'data' | 'observacoes', value: string) => void;
  onFileUpload: (id: string, file: File) => void;
  onRemoveFile: (id: string, anexoId: number) => void;
  onSave: (id: string) => void;
  gerarParecer: (id: string) => void;
  getStatusBadge: (status: string) => JSX.Element;
  loading: boolean;
  currentCompetenciaId: string | null;
}) => {
  const [uploading, setUploading] = useState(false);
  const [anexos, setAnexos] = useState<Anexo[]>(item.anexos || []);

  // Carregar anexos quando o componente monta
  useEffect(() => {
    const loadAnexos = async () => {
      if (currentCompetenciaId) {
        try {
          const tipoAnexo = getTipoAnexoFromItemId(item.id);
          const anexosData = await listAnexos(currentCompetenciaId);
          const filteredAnexos = anexosData.filter(anexo => anexo.tipo_anexo === tipoAnexo);
          setAnexos(filteredAnexos);
        } catch (error) {
          console.error('Erro ao carregar anexos:', error);
        }
      }
    };
    loadAnexos();
  }, [currentCompetenciaId, item.id]);

  const handleFileUpload = async (file: File) => {
    if (!currentCompetenciaId) {
      alert('Nenhuma competência selecionada');
      return;
    }

    if (!validateFileType(file)) {
      alert('Tipo de arquivo não permitido. Use PDF, DOC, DOCX, XLS, XLSX, TXT, JPG ou PNG.');
      return;
    }

    try {
      setUploading(true);
      const tipoAnexo = getTipoAnexoFromItemId(item.id);
      const novoAnexo = await uploadAnexo(currentCompetenciaId, tipoAnexo, file);
      setAnexos(prev => [...prev, novoAnexo]);
      onFileUpload(item.id, file);
    } catch (error) {
      console.error('Erro ao fazer upload:', error);
      alert('Erro ao fazer upload do arquivo');
    } finally {
      setUploading(false);
    }
  };

  const handleRemoveAnexo = async (anexoId: number) => {
    try {
      await removeAnexo(anexoId);
      setAnexos(prev => prev.filter(anexo => anexo.id !== anexoId));
      onRemoveFile(item.id, anexoId);
    } catch (error) {
      console.error('Erro ao remover anexo:', error);
      alert('Erro ao remover anexo');
    }
  };

  const handleDownloadAnexo = async (anexo: Anexo) => {
    try {
      await downloadAnexo(anexo.id, anexo.nome_arquivo);
    } catch (error) {
      console.error('Erro ao baixar anexo:', error);
      alert('Erro ao baixar anexo');
    }
  };

  // Se for o Parecer Final, renderizar interface especial de IA
  if (item.id === '8') {
    return (
      <Card className="mb-6">
        <CardHeader>
          <div className="flex justify-between items-start">
            <div>
              <CardTitle className="text-lg flex items-center gap-2">
                <MessageSquare className="h-5 w-5 text-blue-600" />
                {item.title}
              </CardTitle>
              <CardDescription>
                {item.description} - Gerado automaticamente por IA
              </CardDescription>
            </div>
          </div>
        </CardHeader>
        
        <CardContent className="space-y-4">
          <div className="bg-gradient-to-r from-blue-50 to-indigo-50 p-6 rounded-lg border border-blue-200">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-lg font-semibold text-blue-900 mb-2">
                   Gerar Parecer com Inteligência Artificial
                </h3>
                <p className="text-blue-700 text-sm">
                  A IA analisará todos os campos preenchidos e gerará um parecer completo em Word ou PDF
                </p>
              </div>
              <Button 
                onClick={() => gerarParecer(item.id)}
                size="lg"
                className="bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white"
                disabled={loading}
              >
                <MessageSquare className="h-5 w-5 mr-2" />
                {loading ? 'Gerando...' : 'Gerar Parecer IA'}
              </Button>
            </div>
          </div>

          {/* Lista de anexos do parecer */}
          {anexos.length > 0 && (
            <div className="bg-green-50 border border-green-200 rounded-lg p-4">
              <div className="flex items-center gap-2 text-green-800 mb-3">
                <CheckCircle className="h-4 w-4" />
                <span className="font-medium">Pareceres gerados:</span>
              </div>
              <div className="space-y-2">
                {anexos.map((anexo) => (
                  <div key={anexo.id} className="flex items-center justify-between bg-white p-3 rounded border">
                    <div className="flex items-center gap-2">
                      <FileText className="h-4 w-4 text-green-600" />
                      <span className="text-sm font-medium">{anexo.nome_arquivo || 'Arquivo sem nome'}</span>
                      <span className="text-xs text-gray-500">
                        ({formatFileSize(anexo.tamanho_arquivo || 0)})
                      </span>
                    </div>
                    <div className="flex gap-2">
                      <Button 
                        variant="outline" 
                        size="sm" 
                        onClick={() => handleDownloadAnexo(anexo)}
                        className="text-green-700 border-green-300"
                      >
                        <Download className="h-4 w-4 mr-1" />
                        Baixar
                      </Button>
                      <Button 
                        variant="outline" 
                        size="sm"
                        onClick={() => handleRemoveAnexo(anexo.id)}
                        className="text-red-700 border-red-300"
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {item.lastUpdated && (
            <div className="text-xs text-gray-500 border-t pt-2">
              Última atualização: {formatDateTimeBR(item.lastUpdated)} por {item.updatedBy}
            </div>
          )}
        </CardContent>
      </Card>
    );
  }

  // Renderização normal para outros itens
  return (
    <Card className="mb-6">
      <CardHeader>
        <div className="flex justify-between items-start">
          <div>
            <CardTitle className="text-lg">
              {item.id === '1' && item.data 
                ? formatCompetenciaTitle(item.data)
                : item.title
              }
            </CardTitle>
            <CardDescription>{item.description}</CardDescription>
          </div>
          <div className="flex items-center gap-2">
            {getStatusBadge(item.status)}
            <Button 
              onClick={() => onSave(item.id)}
              size="sm"
              className={item.status === 'concluido' ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-600 hover:bg-blue-700'}
              disabled={loading}
            >
              {loading ? (
                'Salvando...'
              ) : item.status === 'concluido' ? (
                <>
                  <Pencil className="h-4 w-4 mr-1" />
                  Editar
                </>
              ) : (
                <>
                  <Save className="h-4 w-4 mr-1" />
                  Salvar
                </>
              )}
            </Button>
          </div>
        </div>
      </CardHeader>
      
      <CardContent className="space-y-4">
        <div className={`grid grid-cols-1 gap-4 ${(item.id === '4' || item.id === '5') ? 'md:grid-cols-3' : 'md:grid-cols-2'}`}>
          {/* Campo Valor - apenas para Imposto Compensado (id: 4) e Valor Compensado (id: 5) */}
          {(item.id === '4' || item.id === '5') && (
            <div>
              <Label htmlFor={`valor-${item.id}`}>
                <DollarSign className="h-4 w-4 inline mr-1" />
                Valor
              </Label>
              <input
                id={`valor-${item.id}`}
                type="text"
                value={item.valor || ''}
                onChange={(e) => onFieldChange(item.id, 'valor', e.target.value)}
                placeholder="Digite o valor"
                className="mt-1 flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
              />
            </div>
          )}
          
          <div>
            <Label htmlFor={`data-${item.id}`}>
              <Calendar className="h-4 w-4 inline mr-1" />
              {item.id === '1' ? 'Data da Competência' : 'Data'}
            </Label>
            <input
              id={`data-${item.id}`}
              type="date"
              value={item.data || ''}
              onChange={(e) => onFieldChange(item.id, 'data', e.target.value)}
              className="mt-1 flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
            />
          </div>
          
          <div>
            <Label htmlFor={`observacoes-${item.id}`}>
              <MessageSquare className="h-4 w-4 inline mr-1" />
              Observações
            </Label>
            <Textarea
              id={`observacoes-${item.id}`}
              value={item.observacoes || ''}
              onChange={(e) => onFieldChange(item.id, 'observacoes', e.target.value)}
              placeholder="Digite suas observações aqui..."
              className="mt-1 w-full min-h-[80px] resize-none"
              rows={3}
            />
          </div>
        </div>

        {/* Seção de Anexos */}
        <div>
          <Label htmlFor={`anexo-${item.id}`}>Anexar Arquivo</Label>
          <div className="mt-1">
            {/* Lista de anexos existentes */}
            {anexos.length > 0 && (
              <div className="mb-4 space-y-2">
                {anexos.map((anexo) => (
                  <div key={anexo.id} className="flex items-center justify-between p-3 border rounded-lg bg-gray-50">
                    <div className="flex items-center gap-2">
                      <span className="text-lg">{getFileIcon(anexo.nome_arquivo || 'arquivo')}</span>
                      <div>
                        <span className="text-sm font-medium">{anexo.nome_arquivo || 'Arquivo sem nome'}</span>
                        <span className="text-xs text-gray-500 ml-2">
                          ({formatFileSize(anexo.tamanho_arquivo || 0)})
                        </span>
                      </div>
                    </div>
                    <div className="flex gap-2">
                      <Button 
                        variant="outline" 
                        size="sm"
                        onClick={() => handleDownloadAnexo(anexo)}
                      >
                        <Download className="h-4 w-4 mr-1" />
                        Baixar
                      </Button>
                      <Button 
                        variant="outline" 
                        size="sm"
                        onClick={() => handleRemoveAnexo(anexo.id)}
                        className="text-red-600 hover:text-red-700"
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                  </div>
                ))}
              </div>
            )}

            {/* Upload de novo arquivo */}
            <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center">
              <Upload className="h-8 w-8 mx-auto text-gray-400 mb-2" />
              <p className="text-sm text-gray-600 mb-2">
                {uploading ? 'Fazendo upload...' : 'Clique para fazer upload ou arraste o arquivo aqui'}
              </p>
              <Input
                id={`anexo-${item.id}`}
                type="file"
                accept=".pdf,.doc,.docx,.xlsx,.xls,.txt,.jpg,.jpeg,.png"
                onChange={(e) => {
                  const file = e.target.files?.[0];
                  if (file) handleFileUpload(file);
                }}
                className="hidden"
                disabled={uploading}
              />
              <Button
                variant="outline"
                size="sm"
                onClick={() => document.getElementById(`anexo-${item.id}`)?.click()}
                disabled={uploading}
              >
                {uploading ? 'Uploading...' : 'Selecionar Arquivo'}
              </Button>
            </div>
          </div>
        </div>

        {item.lastUpdated && (
          <div className="text-xs text-gray-500 border-t pt-2">
            Última atualização: {formatDateTimeBR(item.lastUpdated)} por {item.updatedBy}
          </div>
        )}
      </CardContent>
    </Card>
  );
});

export default function Compliance() {
  const [currentView, setCurrentView] = useState<'list' | 'create' | 'view'>('list');
  const [selectedCompetencia, setSelectedCompetencia] = useState<Competencia | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Estado para dados reais
  const [competencias, setCompetencias] = useState<Competencia[]>([]);
  const [complianceItems, setComplianceItems] = useState<ComplianceItem[]>([
    { id: '1', title: 'Competência Referencia', description: 'Data da competência fiscal', status: 'pendente' },
    { id: '2', title: 'Relatório Inicial', description: 'Relatório inicial da empresa', status: 'pendente' },
    { id: '3', title: 'Relatório Faturamento', description: 'Relatório de faturamento mensal', status: 'pendente' },
    { id: '4', title: 'Imposto Compensado', description: 'Valor do imposto compensado', status: 'pendente' },
    { id: '5', title: 'Valor Compensado', description: 'Valor total compensado', status: 'pendente' },
    { id: '6', title: 'Emails', description: 'Endereços de e-mail para comunicação', status: 'pendente' },
    { id: '7', title: 'Estabelecimento', description: 'Informações do estabelecimento', status: 'pendente' },
    { id: '8', title: 'Parecer Final', description: 'Parecer gerado pela IA', status: 'pendente' }
  ]);
  const [currentCompetenciaId, setCurrentCompetenciaId] = useState<string | null>(null);

  // API base URL
  const API_BASE = 'http://localhost:3001/api';

  // Mapear IDs dos itens para campos do banco
  const itemFieldMapping: Record<string, string> = {
    '1': 'competencia_referencia',
    '2': 'relatorio_inicial',
    '3': 'relatorio_faturamento',
    '4': 'imposto_compensado',
    '5': 'valor_compensado',
    '6': 'emails',
    '7': 'estabelecimento',
    '8': 'parecer'
  };

  // Função de teste para verificar conexão
  const testConnection = async () => {
    try {
      console.log(' Testando conexão com o backend...');
      
      // Primeiro testar a rota de health
      const healthResponse = await fetch(`${API_BASE}/health`);
      const healthData = await healthResponse.json();
      console.log(' Health check:', healthData);
      
      // Depois testar a rota de competências (rota correta)
      const response = await fetch(`${API_BASE}/compliance/competencias`);
      const data = await response.json();
      console.log(' Resposta do backend:', data);
      setError(null);
    } catch (err) {
      console.error(' Erro na conexão:', err);
      setError('Erro de conexão com o backend');
    }
  };

  // Carregar competências do banco
  const loadCompetencias = async () => {
    try {
      setLoading(true);
      const response = await fetch(`${API_BASE}/compliance/competencias`);
      const data = await response.json();
      
      console.log(' Debug - Resposta da API:', data);
      
      if (data.success) {
        // Se data.data é um objeto, converter para array
        let competenciasData = [];
        if (Array.isArray(data.data)) {
          competenciasData = data.data;
        } else if (data.data && typeof data.data === 'object') {
          // Se é um objeto único, colocar em um array
          competenciasData = [data.data];
        }
        
        setCompetencias(competenciasData);
        console.log(' Competências carregadas:', competenciasData);
      } else {
        setError(data.error);
      }
    } catch (err) {
      setError('Erro ao carregar competências');
      console.error('Erro:', err);
    } finally {
      setLoading(false);
    }
  };

  // Função para criar nova competência
  const createCompetencia = async () => {
    try {
      setLoading(true);
      const competencia_referencia = new Date().toISOString().split('T')[0];
      const created_by = 1;
      
      console.log(' Criando nova competência:', { competencia_referencia, created_by });
      
      const response = await fetch(`${API_BASE}/compliance/competencias`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ competencia_referencia, created_by }),
      });
      
      const data = await response.json();
      
      if (data.success) {
        console.log(' Competência criada:', data.data);
        setCurrentCompetenciaId(data.data.id.toString());
        setCurrentView('create');
        setComplianceItems(prev => prev.map(item => ({
          ...item,
          valor: '',
          data: '',
          observacoes: '',
          anexos: [],
          status: 'pendente',
          lastUpdated: undefined,
          updatedBy: undefined
        })));
      } else {
        console.error(' Erro ao criar competência:', data.error);
        setError(data.error);
      }
    } catch (err) {
      console.error(' Erro na requisição:', err);
      setError('Erro ao criar competência');
    } finally {
      setLoading(false);
    }
  };

  // Salvar campo específico no banco
  const saveFieldToDatabase = async (itemId: string, field: 'valor' | 'data' | 'observacoes', value: string) => {
    if (!currentCompetenciaId) {
      console.error(' Nenhuma competência selecionada');
      return;
    }

    try {
      const dbField = itemFieldMapping[itemId];
      if (!dbField) {
        console.error(' Campo não mapeado:', itemId);
        return;
      }

      console.log(' Salvando no banco:', { 
        competenciaId: currentCompetenciaId, 
        field: dbField, 
        value 
      });

      const response = await fetch(`${API_BASE}/compliance/compliance/${currentCompetenciaId}/field`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ field: dbField, value }),
      });
      
      const data = await response.json();
      
      if (data.success) {
        console.log(' Campo salvo com sucesso:', dbField, value);
      } else {
        console.error(' Erro ao salvar campo:', data.error);
        setError(data.error);
      }
    } catch (err) {
      console.error(' Erro na requisição:', err);
      setError('Erro ao salvar campo');
    }
  };

  // Handlers estáveis com useCallback
  const handleFieldChange = useCallback((id: string, field: 'valor' | 'data' | 'observacoes', value: string) => {
    setComplianceItems(prev => prev.map(item => 
      item.id === id 
        ? { ...item, [field]: value }
        : item
    ));
  }, []);

  const handleFileUpload = useCallback((id: string, file: File) => {
    console.log(' Arquivo selecionado para item:', id, file.name);
    // O upload real é feito no componente ComplianceItemCard
  }, []);

  const handleRemoveFile = useCallback((id: string, anexoId: number) => {
    console.log(' Removendo anexo:', id, anexoId);
    // A remoção real é feita no componente ComplianceItemCard
  }, []);

  // Função para salvar item completo - APENAS quando clicar em Salvar
  const handleSave = useCallback(async (id: string) => {
    const item = complianceItems.find(item => item.id === id);
    if (!item) return;

    // Verificar se há uma competência selecionada
    if (!currentCompetenciaId) {
      setError('Nenhuma competência selecionada. Clique em "Nova Competência" primeiro.');
      return;
    }

    try {
      setLoading(true);
      console.log(' Iniciando salvamento do item:', id, item);
      
      // Salvar cada campo no banco se tiver valor
      const promises = [];
      
      if (item.valor && item.valor.trim()) {
        promises.push(saveFieldToDatabase(id, 'valor', item.valor));
      }
      if (item.data && item.data.trim()) {
        promises.push(saveFieldToDatabase(id, 'data', item.data));
      }
      if (item.observacoes && item.observacoes.trim()) {
        promises.push(saveFieldToDatabase(id, 'observacoes', item.observacoes));
      }

      // Aguardar todas as operações de salvamento
      await Promise.all(promises);

      // Atualizar estado local APENAS após salvar com sucesso
      setComplianceItems(prev => prev.map(comp => 
        comp.id === id 
          ? { 
              ...comp, 
              lastUpdated: new Date().toISOString(), 
              updatedBy: 'Usuário Atual',
              status: 'concluido'
            }
          : comp
      ));

      console.log(' Item salvo com sucesso:', id);

    } catch (err) {
      console.error(' Erro ao salvar item:', err);
      setError('Erro ao salvar item');
    } finally {
      setLoading(false);
    }
  }, [complianceItems, currentCompetenciaId]);

  const gerarParecer = useCallback((id: string) => {
    console.log('Gerando parecer para item:', id);
    // TODO: Implementar geração de parecer com IA
  }, []);

  // Função para obter badge de status - ESTÁVEL
  const getStatusBadge = useCallback((status: string) => {
    switch (status) {
      case 'concluido':
        return <Badge className="bg-green-100 text-green-800"><CheckCircle className="h-3 w-3 mr-1" />Concluído</Badge>;
      case 'em_analise':
        return <Badge className="bg-yellow-100 text-yellow-800"><AlertCircle className="h-3 w-3 mr-1" />Em Análise</Badge>;
      default:
        return <Badge variant="outline"><AlertCircle className="h-3 w-3 mr-1" />Pendente</Badge>;
    }
  }, []);

  // Carregar dados na inicialização
  useEffect(() => {
    console.log(' Carregando competências...');
    loadCompetencias();
  }, []);

  // Renderizar tela de lista
  const renderListCompetencias = () => (
    <div className="p-6 space-y-6">
      <div className="flex justify-between items-center">
          <h1 className="text-3xl font-bold">Compliance Fiscal</h1>
        <div className="flex gap-2">
          <Button onClick={testConnection} variant="outline">
            Testar Conexão
          </Button>
          <Button onClick={createCompetencia} className="bg-blue-600 hover:bg-blue-700" disabled={loading}>
            <Plus className="h-4 w-4 mr-2" />
            {loading ? 'Criando...' : 'Nova Competência'}
          </Button>
        </div>
      </div>

      {error && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4">
          <p className="text-red-800"> {error}</p>
        </div>
      )}

      {/* Debug info */}
      <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
        <h3 className="font-semibold mb-2">Debug Info:</h3>
        <p>Competências: {JSON.stringify(competencias)}</p>
        <p>Tipo: {typeof competencias}</p>
        <p>É array: {Array.isArray(competencias)}</p>
        <p>Length: {competencias?.length || 'N/A'}</p>
      </div>

      {/* Lista de competências em formato vertical */}
      <div className="space-y-3">
        {Array.isArray(competencias) && competencias.length > 0 ? (
          competencias.map((competencia) => (
            <div 
              key={competencia.id} 
              className="flex items-center justify-between p-4 border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors"
            >
              <div className="flex-1">
                <div className="flex items-center gap-3">
                  <h3 className="text-lg font-semibold text-gray-900">
                    Competência {competencia.competencia_formatada || 'N/A'}
                  </h3>
                  <Badge variant={competencia.status === 'concluida' ? 'default' : 'outline'}>
                    {competencia.status === 'concluida' ? 'Concluída' : 'Em Andamento'}
                  </Badge>
                </div>
                <div className="mt-1 text-sm text-gray-600">
                  <p>Criado por {competencia.created_by_nome || 'Usuário'}</p>
                  <p>Criado em: {formatDateBR(competencia.created_at)}</p>
                  {competencia.parecer_gerado && (
                    <p className="text-green-600 font-medium">
                       Parecer gerado
                    </p>
                  )}
                </div>
              </div>
              <div className="flex gap-2">
                <Button 
                  variant="outline" 
                  size="sm"
                  onClick={() => {
                    setSelectedCompetencia(competencia);
                    setCurrentCompetenciaId(competencia.id.toString());
                    setCurrentView('view');
                  }}
                >
                  <Eye className="h-4 w-4 mr-1" />
                  Visualizar
                </Button>
              </div>
            </div>
          ))
        ) : (
          <div className="text-center py-8">
            <p className="text-gray-500">Nenhuma competência encontrada</p>
            <Button 
              onClick={createCompetencia} 
              className="mt-4 bg-blue-600 hover:bg-blue-700"
              disabled={loading}
            >
              <Plus className="h-4 w-4 mr-2" />
              {loading ? 'Criando...' : 'Criar Primeira Competência'}
            </Button>
          </div>
        )}
      </div>
    </div>
  );

  // Renderizar tela de criação
  const renderCreateCompetencia = () => (
    <div className="p-6 space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="outline" onClick={() => setCurrentView('list')}>
          <ArrowLeft className="h-4 w-4 mr-2" />
          Voltar
        </Button>
        <h1 className="text-3xl font-bold">Nova Competência</h1>
      </div>

      <div className="space-y-6">
        {complianceItems.map((item) => (
          <ComplianceItemCard
            key={item.id}
            item={item}
            onFieldChange={handleFieldChange}
            onFileUpload={handleFileUpload}
            onRemoveFile={handleRemoveFile}
            onSave={handleSave}
            gerarParecer={gerarParecer}
            getStatusBadge={getStatusBadge}
            loading={loading}
            currentCompetenciaId={currentCompetenciaId}
          />
        ))}
      </div>
    </div>
  );

  // Renderizar tela de visualização
  const renderViewCompetencia = () => (
    <div className="p-6 space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="outline" onClick={() => setCurrentView('list')}>
          <ArrowLeft className="h-4 w-4 mr-2" />
          Voltar
        </Button>
        <div>
          <h1 className="text-3xl font-bold">
            Competência {selectedCompetencia?.mes}/{selectedCompetencia?.ano}
          </h1>
          <p className="text-gray-600">
            Criado por {selectedCompetencia?.created_by_nome}
          </p>
        </div>
      </div>

      <div className="space-y-6">
        {complianceItems.map((item) => (
          <ComplianceItemCard
            key={item.id}
            item={item}
            onFieldChange={handleFieldChange}
            onFileUpload={handleFileUpload}
            onRemoveFile={handleRemoveFile}
            onSave={handleSave}
            gerarParecer={gerarParecer}
            getStatusBadge={getStatusBadge}
            loading={loading}
            currentCompetenciaId={currentCompetenciaId}
          />
        ))}
      </div>
    </div>
  );

  // Renderizar conteúdo baseado na view atual
  if (currentView === 'list') {
    return renderListCompetencias();
  } else if (currentView === 'create') {
    return renderCreateCompetencia();
  } else if (currentView === 'view') {
    return renderViewCompetencia();
  }

  return null;
}
